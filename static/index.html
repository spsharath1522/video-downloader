<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Downloader</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,600;0,9..40,700;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #18181c;
      --border: #2a2a30;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #22d3ee;
      --accent-hover: #67e8f9;
      --success: #4ade80;
      --error: #f87171;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'DM Sans', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      margin: 0;
      padding: 2rem;
      line-height: 1.5;
    }

    .container {
      max-width: 560px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      margin: 0 0 0.5rem;
      letter-spacing: -0.02em;
    }

    .subtitle {
      color: var(--muted);
      margin: 0 0 2rem;
      font-size: 0.95rem;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.25rem;
    }

    label {
      display: block;
      font-weight: 600;
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
      color: var(--muted);
    }

    input[type="url"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      outline: none;
      transition: border-color 0.15s;
    }

    input[type="url"]::placeholder {
      color: var(--muted);
    }

    input[type="url"]:focus {
      border-color: var(--accent);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1.25rem;
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }

    .btn-primary {
      background: var(--accent);
      color: var(--bg);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-hover);
    }

    .btn-primary:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn-download {
      background: var(--success);
      color: #052e16;
      margin-top: 1rem;
    }

    .btn-download:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-download:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .row {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .row .input-wrap {
      flex: 1;
      min-width: 200px;
    }

    .formats-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .formats-list li {
      padding: 0.75rem 1rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .formats-list li:hover {
      border-color: var(--muted);
      background: rgba(255,255,255,0.02);
    }

    .formats-list li.selected {
      border-color: var(--accent);
      background: rgba(34, 211, 238, 0.08);
    }

    .formats-list input {
      accent-color: var(--accent);
      width: 1rem;
      height: 1rem;
    }

    .format-label {
      font-weight: 600;
    }

    .format-note {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .meta {
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .meta strong {
      color: var(--text);
    }

    .message {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-size: 0.9rem;
      margin-top: 1rem;
    }

    .message.error {
      background: rgba(248, 113, 113, 0.15);
      color: var(--error);
    }

    .message.success {
      background: rgba(74, 222, 128, 0.15);
      color: var(--success);
    }

    .message.info {
      background: rgba(34, 211, 238, 0.1);
      color: var(--accent);
    }

    .hidden {
      display: none;
    }

    .spinner {
      width: 1rem;
      height: 1rem;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .progress-wrap {
      margin-top: 1rem;
      display: none;
    }

    .progress-wrap.visible {
      display: block;
    }

    .progress-bar {
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: var(--accent);
      border-radius: 4px;
      transition: width 0.2s ease-out;
    }

    .progress-text {
      font-size: 0.85rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Media Downloader</h1>
    <p class="subtitle">YouTube, Spotify, Apple Music, adult sites & 1000+ more — paste any link, pick a format, then download.</p>

    <div class="card">
      <label for="url">Media URL</label>
      <div class="row">
        <div class="input-wrap">
          <input type="url" id="url" placeholder="YouTube, Spotify, Pornhub, XVideos, or any media link..." autocomplete="off">
        </div>
        <button type="button" class="btn btn-primary" id="fetchBtn">Fetch formats</button>
      </div>
    </div>

    <div class="card hidden" id="formatsCard">
      <div class="meta" id="meta"></div>
      <label>Available formats (video + audio)</label>
      <ul class="formats-list" id="formatsList"></ul>
      <button type="button" class="btn btn-download" id="downloadBtn" disabled>Download</button>
      <div class="progress-wrap" id="progressWrap">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Preparing…</div>
      </div>
      <div id="downloadMessage" class="message hidden"></div>
    </div>
  </div>

  <script>
    const urlInput = document.getElementById('url');
    const fetchBtn = document.getElementById('fetchBtn');
    const formatsCard = document.getElementById('formatsCard');
    const meta = document.getElementById('meta');
    const formatsList = document.getElementById('formatsList');
    const downloadBtn = document.getElementById('downloadBtn');
    const downloadMessage = document.getElementById('downloadMessage');

    let currentData = null;
    let selectedFormatSpec = null;

    fetchBtn.addEventListener('click', async () => {
      const url = urlInput.value.trim();
      if (!url) {
        showMessage(downloadMessage, 'Paste a URL first.', 'error');
        downloadMessage.classList.remove('hidden');
        return;
      }

      setLoading(fetchBtn, true);
      downloadMessage.classList.add('hidden');
      formatsCard.classList.add('hidden');

      try {
        const res = await fetch('/api/formats', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.detail || res.statusText || 'Failed to fetch formats');
        }
        currentData = data;
        selectedFormatSpec = null;
        renderFormats(data);
        formatsCard.classList.remove('hidden');
        downloadBtn.disabled = true;
      } catch (e) {
        showMessage(downloadMessage, e.message || 'Could not fetch formats.', 'error');
        downloadMessage.classList.remove('hidden');
      } finally {
        setLoading(fetchBtn, false);
      }
    });

    function renderFormats(data) {
      meta.innerHTML = `Title: <strong>${escapeHtml(data.title || 'Unknown')}</strong>`;
      formatsList.innerHTML = (data.formats || []).map((f, i) => `
        <li data-format-spec="${escapeHtml(f.format_spec)}" data-id="${escapeHtml(f.id)}" role="button" tabindex="0">
          <input type="radio" name="format" value="${escapeHtml(f.format_spec)}" id="fmt_${i}">
          <div>
            <span class="format-label">${escapeHtml(f.label)}</span>
            ${f.note ? `<div class="format-note">${escapeHtml(f.note)}</div>` : ''}
          </div>
        </li>
      `).join('');

      formatsList.querySelectorAll('li').forEach(li => {
        li.addEventListener('click', () => {
          formatsList.querySelectorAll('li').forEach(l => l.classList.remove('selected'));
          li.classList.add('selected');
          li.querySelector('input').checked = true;
          selectedFormatSpec = li.dataset.formatSpec;
          downloadBtn.disabled = false;
        });
        li.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            li.click();
          }
        });
      });
    }

    const progressWrap = document.getElementById('progressWrap');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');

    function showProgress(visible, percent, text) {
      progressWrap.classList.toggle('visible', !!visible);
      if (progressFill) progressFill.style.width = (percent ?? 0) + '%';
      if (progressText) progressText.textContent = text || 'Preparing…';
    }

    downloadBtn.addEventListener('click', async () => {
      if (!currentData || !selectedFormatSpec) return;

      setLoading(downloadBtn, true);
      downloadMessage.classList.add('hidden');
      showProgress(true, 0, 'Starting download…');

      try {
        const startRes = await fetch('/api/download/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            url: currentData.url,
            format_spec: selectedFormatSpec,
          }),
        });
        if (!startRes.ok) {
          const err = await startRes.json().catch(() => ({}));
          throw new Error(err.detail || 'Failed to start download');
        }
        const { job_id } = await startRes.json();
        if (!job_id) throw new Error('No job id returned');

        const poll = () => fetch('/api/download/status/' + job_id).then(r => r.json());
        let status = await poll();
        while (status.status === 'downloading') {
          showProgress(true, status.progress, 'Downloading… ' + (status.progress || 0) + '%');
          await new Promise(r => setTimeout(r, 400));
          status = await poll();
        }

        if (status.status === 'error') {
          throw new Error(status.error || 'Download failed');
        }

        showProgress(true, 100, 'Complete. Saving file…');
        const fileRes = await fetch('/api/download/file/' + job_id);
        if (!fileRes.ok) {
          const err = await fileRes.json().catch(() => ({}));
          throw new Error(err.detail || 'Failed to get file');
        }
        const blob = await fileRes.blob();
        const disposition = fileRes.headers.get('Content-Disposition');
        let filename = status.filename || 'media.mp4';
        if (disposition) {
          const m = disposition.match(/filename="?([^";]+)"?/);
          if (m) filename = decodeURIComponent(m[1].trim());
        }
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
        showProgress(false);
        showMessage(downloadMessage, 'Download complete.', 'success');
        downloadMessage.classList.remove('hidden');
      } catch (e) {
        showProgress(false);
        showMessage(downloadMessage, e.message || 'Download failed.', 'error');
        downloadMessage.classList.remove('hidden');
      } finally {
        setLoading(downloadBtn, false);
      }
    });

    function setLoading(btn, loading) {
      if (loading) {
        btn.disabled = true;
        btn.dataset.originalText = btn.textContent;
        btn.innerHTML = '<span class="spinner"></span> Loading...';
      } else {
        btn.disabled = false;
        btn.textContent = btn.dataset.originalText || btn.textContent;
      }
    }

    function showMessage(el, text, type) {
      el.textContent = text;
      el.className = 'message ' + (type || 'info');
    }

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }
  </script>
</body>
</html>
